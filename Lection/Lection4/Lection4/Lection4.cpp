// Lection4.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream>
#include <string>
#include <iomanip>
/*
Указатель – переменная, значением которой является адрес ячейки памяти. 
То есть указатель ссылается на блок данных  из области памяти, причём на самое его начало. 
Указатель может ссылаться на переменную или функцию. Для этого нужно знать адрес переменной или функции. 
Так вот, чтобы узнать адрес конкретной переменной в С++ существует унарная операция взятия адреса &. 
Такая операция извлекает адрес объявленных переменных, для того, чтобы его присвоить указателю.

Указатели используются для передачи по ссылке данных, что намного ускоряет процесс обработки этих данных 
(в том случае, если объём данных большой), так как их не надо копировать, как при передаче по значению, 
то есть, используя имя переменной. В основном указатели используются для организации динамического распределения памяти, 
например при объявлении массива, не надо будет его ограничивать в размере. Ведь программист заранее не может знать, 
какого размера нужен массив тому или иному пользователю, в таком случае используется динамическое выделение памяти под массив. 
Любой указатель необходимо объявить перед использованием, как и любую переменную.

Принцип объявления указателей такой же, как и принцип объявления переменных. 
Отличие заключается только в том, что перед именем ставится символ звёздочки *.
Визуально указатели отличаются от переменных только одним символом. При объявлении 
указателей компилятор выделяет несколько байт памяти, в зависимости от типа данных отводимых
для хранения некоторой информации в памяти. Чтобы получить значение, записанное в некоторой области, 
на которое ссылается указатель нужно воспользоваться операцией разыменования указателя *. 
Необходимо поставить звёздочку перед именем и получим доступ к значению указателя.
*/

using namespace std;

int nod(int number1, int number2) //рекурсивная функция нахождения наибольшего общего делителя НОД
{
	if (number2 == 0)						//базовое решение
		return number1;
	return nod(number2, number1 % number2); //рекурсивное решение НОД
}

void fillArray(int arrayForFilling[], int size)
{
	for (int i = 0; i < size; i++)
	{
		arrayForFilling[i] = i + 1;
	}
}

void ShowArray(int arrayForFilling[], int size)
{
	for (int i = 0; i < size; i++)
	{
		cout << arrayForFilling[i] << "  ";
	}
	cout << endl;
}

int main()
{
	setlocale(LC_ALL, "Russian");

	#pragma region Пример №1
	/*
	int var = 123;		 //инициализация переменной var числом 123
	int *ptrvar = &var;	 //указатель на переменную var (присвоили адрес переменной указателю)
	 
	cout << "&var    = " << &var << endl;    //адрес переменной var содержащийся в памяти, извлечённый операцией взятия адреса
	cout << "ptrvar  = " << ptrvar << endl;  //адрес переменной var, является значением указателя ptrvar
	cout << "var     = " << var << endl;	 //значение в переменной var
	cout << "*ptrvar = " << *ptrvar << endl; //вывод значения содержащегося в переменной var через указатель, операцией разименования указателя
	
	
	
	float PI = 3.14159, *p1, *p2;
	p1 = p2 = &PI;
	cout << "По адресу p1=" << p1 << " хранится *p1=" << *p1 << endl;
	cout << "По адресу p2=" << p2 << " хранится *p2=" << *p2 << endl;
	
	float *pt1;  //объявлен указатель на float - ptr1
	double *pt2; //объявлен указатель на double - ptr2
	pt1 = &PI;   //переменной ptr1 присваивается значние адреса PI
	pt2 = (double*)pt1; //указателю на double присваивается значение,
						//которое ссылается на тип float
	cout << "По адресу p1=" << pt1 << " хранится *p1=" << *pt1 << "\n";
	cout << "По адресу p2=" << pt2 << " хранится *p2=" << *pt2 << "\n";
	
	
	double PId = 3.14159, *ptr1; float *ptr2;
	ptr1 = &PId;
	ptr2 = (float *)ptr1;
	cout << "По адресу p1=" << ptr1 << " хранится *p1=" << *ptr1 << "\n";
	cout << "По адресу p2=" << ptr2 << " хранится *p2=" << *ptr2 << "\n";
	*/
	#pragma endregion
	
	#pragma region Сравнение значений
	/*
	int var1 = 123; // инициализация переменной var1 числом 123
	int var2 = 99; // инициализация переменной var2 числом 99
	int *ptrvar1 = &var1; // указатель на переменную var1
	int *ptrvar2 = &var2; // указатель на переменную var2
	cout << "var1    = " << var1 << endl;
	cout << "var2    = " << var2 << endl;
	cout << "ptrvar1 = " << ptrvar1 << endl;
	cout << "ptrvar2 = " << ptrvar2 << endl;
	if (ptrvar1 > ptrvar2) // сравниваем значения указателей, то есть адреса переменных
		cout << "ptrvar1 > ptrvar2" << endl;
	if (*ptrvar1 > *ptrvar2) // сравниваем значения переменных, на которые ссылаются указатели
		cout << "*ptrvar1 > *ptrvar2" << endl;
	*/
	#pragma endregion

	#pragma region Указатель указателя
	/*
	int var = 123; // инициализация переменной var числом 123
	int *ptrvar = &var; // указатель на переменную var
	int **ptr_ptrvar = &ptrvar; // указатель на указатель на переменную var
	int ***ptr_ptr_ptrvar = &ptr_ptrvar;
	cout << " *ptrvar\t= " << ptrvar << endl;
	cout << " **ptr_ptrvar   = " << ptr_ptrvar << endl; // два раза разименовываем указатель, так как он второго порядка
	cout << " ***ptr_ptrvar  = " << ptr_ptr_ptrvar << endl; // указатель третьего порядка
	cout << "из 3 в 1 " << **ptr_ptr_ptrvar << endl;
	
	cout << " var\t\t= " << var << endl;
	cout << " *ptrvar\t= " << *ptrvar << endl;
	cout << " **ptr_ptrvar   = " << **ptr_ptrvar << endl; // два раза разименовываем указатель, так как он второго порядка
	cout << " ***ptr_ptrvar  = " << ***ptr_ptr_ptrvar << endl; // указатель третьего порядка
	cout << "\n ***ptr_ptr_ptrvar -> **ptr_ptrvar -> *ptrvar ->      var -> " << var << endl;
	cout << "\t  " << &ptr_ptr_ptrvar << " -> " << "    " << &ptr_ptrvar << " ->" << &ptrvar << " -> " << &var << " -> " << var << endl;
	*/
	#pragma endregion

	#pragma region НОД
	/*
	int(*ptrnod)(int, int); // объявление указателя на функцию
	ptrnod = nod; // присваиваем адрес функции указателю ptrnod
	int a, b;
	cout << "Введите первое число: ";
	cin >> a;
	cout << "Введите второе число: ";
	cin >> b;
	cout << "НОД = " << ptrnod(a, b) << endl; // обращаемся к функции через указатель
	*/
	#pragma endregion

	#pragma region Операции

		#pragma region Косвенная адресация
			/*
			int *uk;
			int n;
			int m = 5;
			uk = &m;      // uk присвоен адрес переменной m     
			n = *uk;      // переменная n примет значение 5 
			*uk = -13;    // переменная m примет значение -13
			cout << n << endl;
			cout << m << endl;
			*/
		#pragma endregion

		#pragma region Декремент/инкремент
			/*
			long b, *ptrb;      // b – переменная типа long длиной 4 байта, ptr – указатель на объект long длиной 4 байта
			double c, *ptrc;    // c – переменная типа double длиной 8 байта, ptr – указатель на объект long длиной 4 байта
			ptrb = &b;		   // в ptrb адрес переменной b
			ptrc = &c;		   // в ptrc адрес переменной c
			cout << "bptr = " << ptrb << endl;
			cout << "cptr = " << ptrc << endl;

			cout << "Инкремент bptr = " << ++ptrb << endl;
			cout << "Декремент bptr = " << --ptrb << endl;
			cout << "Инкремент cptr = " << ++ptrc << endl;
			cout << "Декремент cptr = " << --ptrc << endl;
			*/
		#pragma endregion

		#pragma region Сложение/вычитание
		/*
		double d;
		int n = 3;
		double *uk;
		uk = &d;	   //в uk адрес переменной d 
		cout << uk << endl;
		uk = uk + n;   //в результате выполнения операции сложения, а затем операции присваивания, в uk новый адрес на 24 больше, чем предыдущий 
		cout << uk << endl;
		uk = n + uk;   //в uk адрес увеличился еще на 24
		cout << uk << endl;
		uk = uk - n;   //в результате выполнения операции вычитания, а затем операции присваивания, в uk новый адрес на 24 меньше, чем предыдущий
		cout << uk << endl;
		*/
		#pragma endregion

		/*
	Следующие операции недопустимы с указателями:
		сложение двух указателей;
		вычитание двух указателей на различные объекты;
		сложение указателей с числом с плавающей точкой;
		вычитание из указателей числа с плавающей точкой;
		умножение указателей;
		деление указателей;
		поразрядные операции и операции сдвига;
	*/

	#pragma endregion

	#pragma region Битовые операции
	/*
	int a = 12;
	int b = 023; //19 в 10чной системе счисления
	int c = 0xff;//255 в 10чной системе счисления

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;

	int summ = a + b + c;
	cout << "summ = " << summ << endl;

	unsigned int var_a(7); //000000000000111
	unsigned int var_b(37);//000000000100101

	cout << "var_a = " << var_a << endl;
	cout << "var_b = " << var_b << endl << endl;

	cout << "~var_a = " << (~var_a) << endl;
	cout << "~var_b = " << (~var_b) << endl << endl;

	cout << "var_a & var_b = " << (var_a & var_b) << endl; //Побитовое И
	cout << "var_a | var_b = " << (var_a | var_b) << endl; //Побитовое ИЛИ
	cout << "var_a ^ var_b = " << (var_a ^ var_b) << endl; //Побитовое исключающее ИЛИ

	cout << "var_a << 2 = " << (var_a << 2) << endl;
	cout << "var_b >> 1 = " << (var_b >> 1) << endl;
	*/
	#pragma endregion

	#pragma region Массивы
	/*
	cout << "Обработка массива" << endl;
	int array1[16] = { 5, -12, -12, 9, 10, 0, -9,
	-12, -1, 23, 65, 64, 11, 43, 39, -15 }; //объявление и инициализация одномерного массива
	cout << "Индекс" << "\t\t" << "Элемент массива" << endl; // печать заголовков
	for (int counter = 0; counter < 16; counter++)  //начало цикла
	{
		//вывод на экран индекса ячейки массива, а затем содержимого этой ячейки, в нашем случае - это целое число
		cout << "array1[" << counter << "]" << "\t\t" << array1[counter] << endl;
	}
	*/
	#pragma endregion
	
	#pragma region Сумма элементов
	/*
	int array1[10]; // объявляем целочисленный массив
	cout << "Введите элемент массива: " << endl;
	int sum = 0;
	for (int counter = 0; counter < 10; counter++) // цикл для считывания чисел
		cin >> array1[counter];  // считываем вводимые с клавиатуры числа
	cout << "array1 = {";
	for (int counter = 0; counter < 10; counter++) // цикл для вывода элементов массива
	{
		cout << array1[counter] << " ";  // выводим элементы массива на стандартное устройство вывода
		sum += array1[counter]; // суммируем элементы массива
	}
	cout << "}\nsum = " << sum << endl;
	*/
	#pragma endregion

	#pragma region Лабиринт
	/*
	// 1-условно "стенки лабиринта"
	// 2-"правильный путь, выход из лабиринта"
	// 0-"ложный путь"
		int mas[33][20] = { { 1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, }, // инициализация двумерного массива
							{ 1,2,1,0,0,1,0,1,2,2,2,1,1,1,1,0,0,0,0,1, },
							{ 1,2,1,1,0,1,0,1,2,1,2,2,2,2,1,0,1,1,0,1, },
							{ 1,2,2,2,2,2,2,1,2,1,1,1,1,2,1,0,0,1,0,1, },
							{ 1,1,1,1,1,1,2,1,2,1,0,0,1,2,1,1,0,1,0,1, },
							{ 1,0,0,1,0,0,2,2,2,1,1,0,0,2,0,0,0,1,0,1, },
							{ 1,0,1,1,0,1,1,1,1,1,0,0,1,2,1,1,1,1,0,1, },
							{ 1,0,0,0,0,0,0,0,0,1,1,1,1,2,1,0,0,0,0,1, },
							{ 1,1,1,1,1,1,0,1,1,1,2,2,2,2,1,0,1,1,1,1, },
							{ 1,1,0,0,0,1,0,0,1,1,2,1,1,1,1,0,0,0,0,1, },
							{ 1,0,0,1,0,0,0,0,0,1,2,2,2,2,1,1,1,1,0,1, },
							{ 1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,0,0,0,0,1, },
							{ 1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,1,1,1,1, },
							{ 1,2,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1, },
							{ 1,2,1,0,0,0,1,2,2,2,1,0,0,0,0,0,1,1,0,1, },
							{ 1,2,1,1,1,1,1,2,1,2,1,1,1,0,1,0,0,0,0,1, },
							{ 1,2,1,2,2,2,1,2,1,2,2,2,1,1,1,1,1,1,1,1, },
							{ 1,2,1,2,1,2,1,2,1,0,1,2,2,2,2,2,2,2,2,1, },
							{ 1,2,1,2,1,2,1,2,1,0,1,1,1,1,1,1,1,1,2,1, },
							{ 1,2,1,2,1,2,1,2,1,0,0,0,0,0,0,0,0,0,2,1, },
							{ 1,2,1,2,1,2,2,2,1,0,1,1,1,1,1,1,0,1,2,1, },
							{ 1,2,1,2,1,1,1,1,1,0,0,0,1,0,1,0,0,1,2,1, },
							{ 1,2,1,2,2,1,0,0,1,1,1,0,0,0,1,0,1,1,2,1, },
							{ 1,2,1,1,2,1,1,0,0,0,0,0,1,0,1,0,0,1,2,1, },
							{ 1,2,1,1,2,1,0,0,1,1,1,1,1,1,1,1,1,1,2,1, },
							{ 1,2,1,1,2,1,1,0,1,2,2,2,2,2,2,2,2,2,2,1, },
							{ 1,2,1,1,2,1,0,0,1,2,1,1,1,1,1,1,1,1,1,1, },
							{ 1,2,1,1,2,1,0,1,1,2,1,1,1,1,1,1,1,1,2,2, },
							{ 1,2,1,1,2,1,0,0,1,2,1,1,2,2,2,2,2,2,2,1, },
							{ 1,2,1,1,2,1,0,1,1,2,1,1,2,1,1,1,1,1,1,1, },
							{ 1,2,1,1,2,1,0,0,1,2,1,1,2,1,0,0,0,1,0,1, },
							{ 1,2,2,2,2,1,0,1,1,2,2,2,2,0,0,1,0,0,0,1, },
							{ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, } };
		// два цикла - внутренний и внешний, осуществляющие обращение к каждому элементу массива
		for (int i = 0; i < 33; i++) //переключение по строкам
		{
			for (int j = 0; j < 20; j++)// переключение по столбцам
				if (mas[i][j] == 1)
				{
					// вывести два раза символ (номер которого 176 в таблице аски) в консоль
					cout << static_cast<char>(1);
					cout << static_cast<char>(1);
				}
				else
					cout << "  ";  // вывести два пробела
			cout << endl;
		}	
		*/
	#pragma endregion
	
	#pragma region Вывод
		/*
		string students[10] = {
			"Иванов", "Петров", "Сидоров",
			"Ахмедов", "Ерошкин", "Выхин",
			"Андеев", "Вин Дизель", "Картошкин", "Чубайс"
		};
		string *ptrStudents = students;
		cout << ptrStudents << endl;
		cout << *(++ptrStudents) << endl;
		*/	
		
		#pragma endregion
		

	const int SIZE1 = 8;
	const int SIZE2 = 14;

	int arrayForFilling1[SIZE1] = {};
	int arrayForFilling2[SIZE2] = {};

	fillArray(arrayForFilling1, SIZE1);
	ShowArray(arrayForFilling1, SIZE1);
	fillArray(arrayForFilling2, SIZE2);
	ShowArray(arrayForFilling2, SIZE2);

	system("pause");
    return 0;
}

